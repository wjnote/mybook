## 主要是ES6 开发中记录的一些点
对象的扩展运算符（...），ES2018将这个运算符引入了对象

### 扩展运算符作为解构复制 用法
**对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。扩展运算符一般在等号左边**
```js
let {x, y, ...z} = {x:1,y:2,c:3,d:4}
z // {c:3,d:4}
```
- 变量 z 是结构赋值的对象，获取等号右边的所有未读取的键，将他们全部拷贝
- 解构复制要求等号右边必须是一个对象，undefined,null不能转为对象的就会报错
- 解构赋值必须是最后一个参数，否则报错 `let {...x, y, z}`
- 解构赋值的拷贝是浅拷贝，复杂对象时拷贝的是对象的引用，而不是副本
- 扩展运算符的解构赋值，不能复制继承自原型对象的属性
- 解构赋值可以扩展某个函数的参数，引入其他操作
```js
const o = Object.create({x:1, y:2});
o.z = 3;

let {x, ...newObj} = o;
let {y, z} = newObj;

x //1
y // undefined
z // 3
// x 是读取值可以读取到，但是newObj复制的时候不能复制继承的属性，
```

### 扩展运算符 用法
**对象的扩展运算符（...） 用于取出参数对象的所有可遍历的对象，拷贝到当前对象之中.扩展运算符一般在等号左边**
```js
let z= {a:1, b:2}
let n= {...z}
n // {a: 1,b:2}

let foo = { ...['a','b','c']}
foo // {0:a, 1: b,2:c}   数据是特殊的对象，对象的扩展运算符也可以作用与数组
```
- 扩展运算符后面是空对象，则没有任何效果
- 扩展运算符后面不是对象，则会自动将其转换为对象
- 扩展运算符后面是字符串，它会转换成一个类似数组的对象，
- 扩展运算符等同于使用了 `Object.assign({}, temp)`方法
- 扩展运算符可以合并多个对象， `let a ={...a, ...b}`
- 后面的属性会覆盖前面的属性
- 与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式，一般是三元表达式
- 扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的

```js
let runtime ={
    ...{
        get x(){
            throw new Error('throw now')
        }
    }
}
```

### 数组的扩展运算符
**扩展运算符(...)，类似于 rest 参数的逆运算，将一个数组转为用','隔开的参数序列**

```js
console.log(...[1,23,3])  // 1,23,3
console.log(5,...[1,23,3],6)  // 5,1,23,3,6

const number = [4,38]
function add (x,y){return x+y;}
add(...number)  //42
```

- 该运算符主要用于函数调用，将数组转变为参数序列
- 扩展运算符可以和正常的函数参数结合使用。
- 扩展运算符后面还可以放置表达式
- 如果后面是空数组，则没有任何效果
- 扩展运算符如果放在括号中，JS会认为这是函数的调用，如果不是则会报错`(...[1, 2])` 会报错
- 可以替代 apply 方法，也可以了解扩展运算符实现的功能，之前用 apply 也可以实现
- 扩展运算符可以将字符串转为真正的数组
- 任何实现了 Iterator 接口的对象，都可以转为真正的数组

> 其实扩展运算符内部调用的是数据结构的 Iterator 接口，因此主要具有 Iterator接口的对象，都可以使用扩展运算符，比如 Map，Set 结构，Generator函数


### 扩展运算符和解构赋值的结合使用
扩展运算符可以和解构复制结合起来，用于生成数组
```js
a = list[0] ,rest = list.slice(1)

[a, ...rest]  = list;

const [first, ...rest] = [] 
first // undefined
res // []
```